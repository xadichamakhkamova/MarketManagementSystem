// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package storage

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createDebt = `-- name: CreateDebt :one
INSERT INTO debts 
    (
        first_name, 
        last_name, 
        phone_number, 
        jshshir, 
        address, 
        bag_id,
        price,
        price_paid,
        acquaintance, 
        collateral, 
        deadline
    )
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING
    id,
    first_name, 
    last_name, 
    phone_number, 
    jshshir, 
    address, 
    bag_id,
    price,
    price_paid,
    acquaintance, 
    collateral, 
    deadline,
    created_at,
    updated_at,
    deleted_at
`

type CreateDebtParams struct {
	FirstName    string
	LastName     string
	PhoneNumber  string
	Jshshir      string
	Address      string
	BagID        string
	Price        float64
	PricePaid    float64
	Acquaintance sql.NullString
	Collateral   sql.NullString
	Deadline     time.Time
}

type CreateDebtRow struct {
	ID           uuid.UUID
	FirstName    string
	LastName     string
	PhoneNumber  string
	Jshshir      string
	Address      string
	BagID        string
	Price        float64
	PricePaid    float64
	Acquaintance sql.NullString
	Collateral   sql.NullString
	Deadline     time.Time
	CreatedAt    sql.NullTime
	UpdatedAt    sql.NullTime
	DeletedAt    sql.NullInt64
}

func (q *Queries) CreateDebt(ctx context.Context, arg CreateDebtParams) (CreateDebtRow, error) {
	row := q.db.QueryRowContext(ctx, createDebt,
		arg.FirstName,
		arg.LastName,
		arg.PhoneNumber,
		arg.Jshshir,
		arg.Address,
		arg.BagID,
		arg.Price,
		arg.PricePaid,
		arg.Acquaintance,
		arg.Collateral,
		arg.Deadline,
	)
	var i CreateDebtRow
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.Jshshir,
		&i.Address,
		&i.BagID,
		&i.Price,
		&i.PricePaid,
		&i.Acquaintance,
		&i.Collateral,
		&i.Deadline,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteDebt = `-- name: DeleteDebt :exec
UPDATE debts
SET deleted_at = $2
WHERE id = $1
`

type DeleteDebtParams struct {
	ID        uuid.UUID
	DeletedAt sql.NullInt64
}

func (q *Queries) DeleteDebt(ctx context.Context, arg DeleteDebtParams) error {
	_, err := q.db.ExecContext(ctx, deleteDebt, arg.ID, arg.DeletedAt)
	return err
}

const getDebtByFilter = `-- name: GetDebtByFilter :many
SELECT id, first_name, last_name, phone_number, jshshir, address, bag_id, price, price_paid, acquaintance, collateral, deadline, status, created_at, updated_at, deleted_at FROM debts
WHERE 
    ($1::text = 'allDataFromDB' OR 
    first_name ILIKE '%' || $1 || '%' OR
    last_name ILIKE '%' || $1 || '%' OR
    phone_number ILIKE '%' || $1 || '%' OR
    jshshir ILIKE '%' || $1 || '%' OR
    address ILIKE '%' || $1 || '%' OR
    acquaintance ILIKE '%' || $1 || '%' OR
    collateral ILIKE '%' || $1 || '%' OR
    CAST(deadline AS text) ILIKE '%' || $1 || '%')
`

func (q *Queries) GetDebtByFilter(ctx context.Context, dollar_1 string) ([]Debt, error) {
	rows, err := q.db.QueryContext(ctx, getDebtByFilter, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Debt
	for rows.Next() {
		var i Debt
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.PhoneNumber,
			&i.Jshshir,
			&i.Address,
			&i.BagID,
			&i.Price,
			&i.PricePaid,
			&i.Acquaintance,
			&i.Collateral,
			&i.Deadline,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDebtById = `-- name: GetDebtById :one
SELECT id, first_name, last_name, phone_number, jshshir, address, bag_id, price, price_paid, acquaintance, collateral, deadline, status, created_at, updated_at, deleted_at FROM debts
WHERE id = $1
`

func (q *Queries) GetDebtById(ctx context.Context, id uuid.UUID) (Debt, error) {
	row := q.db.QueryRowContext(ctx, getDebtById, id)
	var i Debt
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.Jshshir,
		&i.Address,
		&i.BagID,
		&i.Price,
		&i.PricePaid,
		&i.Acquaintance,
		&i.Collateral,
		&i.Deadline,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateDebt = `-- name: UpdateDebt :one
UPDATE debts
SET 
    first_name = COALESCE($2, first_name),
    last_name = COALESCE($3, last_name),
    phone_number = COALESCE($4, phone_number),
    jshshir = COALESCE($5, jshshir),
    address = COALESCE($6, address),
    bag_id = COALESCE($7, bag_id),
    price = COALESCE($8, price),
    price_paid = COALESCE($9, price_paid),
    acquaintance = COALESCE($10, acquaintance),
    collateral = COALESCE($11, collateral),
    deadline = COALESCE($12, deadline),
    updated_at = $13
WHERE id = $1
RETURNING
    id,
    first_name,
    last_name,
    phone_number,
    jshshir,
    address,
    bag_id,
    price,
    price_paid,
    acquaintance,
    collateral,
    deadline,
    created_at,
    updated_at,
    deleted_at
`

type UpdateDebtParams struct {
	ID           uuid.UUID
	FirstName    string
	LastName     string
	PhoneNumber  string
	Jshshir      string
	Address      string
	BagID        string
	Price        float64
	PricePaid    float64
	Acquaintance sql.NullString
	Collateral   sql.NullString
	Deadline     time.Time
	UpdatedAt    sql.NullTime
}

type UpdateDebtRow struct {
	ID           uuid.UUID
	FirstName    string
	LastName     string
	PhoneNumber  string
	Jshshir      string
	Address      string
	BagID        string
	Price        float64
	PricePaid    float64
	Acquaintance sql.NullString
	Collateral   sql.NullString
	Deadline     time.Time
	CreatedAt    sql.NullTime
	UpdatedAt    sql.NullTime
	DeletedAt    sql.NullInt64
}

func (q *Queries) UpdateDebt(ctx context.Context, arg UpdateDebtParams) (UpdateDebtRow, error) {
	row := q.db.QueryRowContext(ctx, updateDebt,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.PhoneNumber,
		arg.Jshshir,
		arg.Address,
		arg.BagID,
		arg.Price,
		arg.PricePaid,
		arg.Acquaintance,
		arg.Collateral,
		arg.Deadline,
		arg.UpdatedAt,
	)
	var i UpdateDebtRow
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.Jshshir,
		&i.Address,
		&i.BagID,
		&i.Price,
		&i.PricePaid,
		&i.Acquaintance,
		&i.Collateral,
		&i.Deadline,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
